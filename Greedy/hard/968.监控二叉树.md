### 968.监控二叉树

#### 最初的思路

> 层次遍历，从下往上
>
> 在每一个叶子节点的上一层放置监控；
>
> 隔一层放置一个	

#### 更优的思路

##### 遍历顺序

后序遍历，因为是要**自底向上**推导，后序遍历就是回溯

后序遍历中要*记录* ===左右孩子的值===，以推导中间节点的状态

##### 如何隔两个节点放一个摄像头

###### 状态转移公式

此时需要状态转移的公式，不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！

1. 该节点无覆盖——0
2. 本节点有摄像头——1
3. 本节点有覆盖——2

空节点应该返回有覆盖状态（2）：

- 因为返回0，该节点需要放摄像头
- 返回1，就不能在叶子节点的父节点放摄像头

###### 四种情况

1. 情况1：左右节点都有覆盖

2. 情况2：左右节点至少有一个无覆盖的情况

   ```java
   // left == 0 && right == 0 左右节点无覆盖
   // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
   // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
   // left == 0 && right == 2 左节点无覆盖，右节点覆盖
   // left == 2 && right == 0 左节点覆盖，右节点无覆盖
   ```

3. 情况3：左右节点至少有一个有摄像头

   ```java
   // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
   // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
   // left == 1 && right == 1 左右节点都有摄像头
   // 其他情况前段代码均已覆盖
   ```

4. 情况4：头结点没有覆盖

​						因为返回无覆盖，是在父节点加上摄像头，所以要考虑头节点无覆盖的情况

```java
public int result;
    public int minCameraCover(TreeNode root) {
        traversal(root);
        //第四种情况
        if (traversal(root)==0)
            result++;
        return result;
    }

    /**
     * 1. 该节点无覆盖——0
     * 2. 本节点有摄像头——1
     * 3. 本节点有覆盖——2
     * @param cur
     * @return
     */
    public int traversal(TreeNode cur){
        //空节点是有覆盖状态
        if (cur==null) return 2;
        int left  = traversal(cur.left);
        int right = traversal(cur.right);
        //情况1：左右节点都有覆盖，该节点无覆盖
        if (left==2&&right==2){
            return 0;
        }
        //情况2：左右节点至少有一个无覆盖的情况
        // left == 0 && right == 0 左右节点无覆盖
        // left == 1 && right == 0 左节点有摄像头，右节点无覆盖
        // left == 0 && right == 1 左节点有无覆盖，右节点摄像头
        // left == 0 && right == 2 左节点无覆盖，右节点覆盖
        // left == 2 && right == 0 左节点覆盖，右节点无覆盖
        if (left==0||right==0){
            result++;
            return 1;
        }
        //情况3：左右节点至少有一个有摄像头
        // left == 1 && right == 2 左节点有摄像头，右节点有覆盖
        // left == 2 && right == 1 左节点有覆盖，右节点有摄像头
        // left == 1 && right == 1 左右节点都有摄像头
        // 其他情况前段代码均已覆盖
        if (left==1||right==1)
            return 2;

        return -1;

    }
```



